// Generated by CoffeeScript 1.3.3
(function() {

  ig.module('game.entities.gates.gate').requires('impact.entity', 'game.entities.message', 'game.entities.gui.problemInterface').defines(function() {
    return window.EntityGate = ig.Entity.extend({
      "interface": null,
      spriteSize: {
        x: 48,
        y: 48
      },
      size: {
        x: 48,
        y: 48
      },
      difficulty: 1,
      font: new ig.Font('media/helvetica32000.png'),
      _wmScalable: true,
      collides: ig.Entity.COLLIDES.FIXED,
      checkAgainst: ig.Entity.TYPE.A,
      init: function(x, y, settings) {
        this.parent(x, y, settings);
        return this.animSheet = new ig.AnimationSheet('media/tileset.png', this.spriteSize.x, this.spriteSize.y);
      },
      check: function() {
        this.parent();
        if (ig.game.state === 'main') {
          if (this.passable()) {
            return this.makeChallenge();
          } else {
            return ig.game.spawnEntity(EntityMessage, this.failMessage());
          }
        }
      },
      makeChallenge: function() {
        ig.game.state = 'problem';
        ig.game.gate = this;
        return this.makeQuestion();
      },
      failMessage: function() {
        if (ig.game.getEntitiesByType(EntityMessage).length === 0) {
          ig.game.record("" + this.gateType + "Gate", "unpassable", null, this.difficulty);
        }
        return "The door won't budge./nYour powers of " + this.gateType + " are not yet strong enough.";
      },
      resolve: function() {
        this["interface"].kill();
        return ig.game.state = 'main';
      },
      draw: function() {
        var ctx, i, j, numColumns, numRows, _i, _j;
        ctx = ig.system.context;
        ctx.save();
        ctx.translate(ig.system.getDrawPos(this.pos.x - this.offset.x - ig.game.screen.x), ig.system.getDrawPos(this.pos.y - this.offset.y - ig.game.screen.y));
        numColumns = Math.floor(this.size.x / this.spriteSize.x);
        numRows = Math.floor(this.size.y / this.spriteSize.y);
        for (i = _i = 0; 0 <= numColumns ? _i < numColumns : _i > numColumns; i = 0 <= numColumns ? ++_i : --_i) {
          for (j = _j = 0; 0 <= numRows ? _j < numRows : _j > numRows; j = 0 <= numRows ? ++_j : --_j) {
            this.currentAnim.draw(i * this.spriteSize.x, j * this.spriteSize.y);
          }
        }
        this.font.draw(this.difficulty, 5, 5);
        return ctx.restore();
      }
    });
  });

}).call(this);
